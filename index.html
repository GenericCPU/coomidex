<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CoOMidex - Final Two-Column Panels</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    /* RESET */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background-color: #000;
      color: #fff;
      font-family: sans-serif;
      overflow: hidden; /* We scroll in .main-content, not the body */
    }

    /* TOP BAR */
    header {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 60px;
      background-color: #000;
      display: flex;
      align-items: center;
      padding: 0 20px;
      z-index: 1000;
    }
    .logo {
      font-size: 20px;
      font-weight: bold;
    }

    /* GENERATION SELECTOR BAR */
    .gen-selector {
      position: fixed;
      top: 60px;
      left: 0;
      width: 100%;
      height: 40px;
      background-color: #151515;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 10px;
      z-index: 1000;
      border-bottom: 1px solid #333;
    }
    .gen-option {
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      cursor: not-allowed;
      opacity: 0.5;
      background-color: #333;
      color: #fff;
      transition: all 0.2s ease;
    }
    .gen-option.selected {
      background-color: #ffff00;
      color: #000;
      opacity: 1;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 255, 0, 0.3);
    }

    /* SCROLLABLE MIDDLE GRID - adjust top position */
    .main-content {
      position: absolute;
      top: 100px;         /* below header + gen selector */
      bottom: 320px;     /* above bottom dash */
      left: 0; right: 0;
      overflow-y: auto;
      padding: 20px;
      background-color: black;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      justify-items: center;
    }
    .grid-item {
      position: relative;
      width: 100px;
      height: 100px;
      border-radius: 8px;
      background-color: #2f2f2f;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .grid-item:hover {
      /* Removed transform scale effect */
    }
    .grid-item img {
      max-width: 93px;
      max-height: 93px;
      border-radius: 4px;
    }

    /* HOLLOW OUTLINES (no fill) */
    .highlight-orange {
      border: 3px dashed orange;
      background: transparent;
      border-radius: 8px;
    }
    .highlight-blue {
      border: 3px dashed dodgerblue;
      background: transparent;
      border-radius: 8px;
    }
    .selected-orange {
      border: 3px solid orange;
      background: transparent;
      border-radius: 8px;
    }
    .selected-blue {
      border: 3px solid dodgerblue;
      background: transparent;
      border-radius: 8px;
    }

    /* BOTTOM DASH (two adjacent panels, no gap) */
    footer {
      position: fixed;
      bottom: 0; left: 0;
      width: 100%;
      height: 320px;
      background-color: #151515; /* Darker background */
      z-index: 1000;
      display: flex;
      align-items: flex-start;
      justify-content: center; 
      gap: 0; /* no gap in the middle */
      padding: 0;
    }

    /* CHAMPION PANELS (each ~50% width) */
    .champion-panel {
      position: relative;
      width: 50%;
      height: 100%;  /* fill entire 320px footer */
      display: flex;
      flex-direction: column;
      border-radius: 0; /* no extra background color */
      overflow: hidden; /* ensure content stays within panel */
      background-color: #151515; /* Match footer color */
    }

    /* SLEEK TOP BAR (reduced height) */
    .panel-top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0;
      height: 8px; /* Slightly taller to make the shape more visible */
      border-top-left-radius: 0px;
      border-top-right-radius: 0px;
      flex-shrink: 0;
      overflow: visible; /* Allow the shape to be visible */
      margin: 0; /* Remove margin to allow bars to touch */
    }

    /* Left panel trapezoid (angled on left side only) */
    #orangePanel .panel-top-bar {
      clip-path: polygon(0% 0%, 10% 100%, 100% 100%, 100% 0%);
    }

    /* Right panel trapezoid (angled on right side only) */
    #bluePanel .panel-top-bar {
      clip-path: polygon(0% 0%, 0% 100%, 90% 100%, 100% 0%);
    }

    .panel-top-bar.orange { 
      background-color: #ffff00;  /* Match selector yellow */
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.7),
                 0 0 30px rgba(255, 255, 0, 0.4),
                 0 0 45px rgba(255, 255, 0, 0.2),
                 0 0 60px rgba(255, 255, 0, 0.1),
                 inset 0 0 15px rgba(255, 255, 255, 0.3);
    }
    .panel-top-bar.blue { 
      background-color: #00ccff;  /* More vibrant blue */
      box-shadow: 0 0 15px rgba(0, 204, 255, 0.7),
                 0 0 30px rgba(0, 204, 255, 0.4),
                 0 0 45px rgba(0, 204, 255, 0.2),
                 0 0 60px rgba(0, 204, 255, 0.1),
                 inset 0 0 15px rgba(255, 255, 255, 0.3);
    }

    /* Hide the title and rarity in top bar */
    .champion-title, .champion-rarity {
      display: none;
    }

    /* MAIN CONTENT => flex:1 => two columns + buy button pinned at bottom */
    .panel-content {
      position: relative;
      flex: 1; /* fill leftover vertical space */
      display: flex;
      flex-direction: row;
      padding: 10px 0px 10px 20px; /* Remove right padding */
      gap: 10px;  /* Reduce default gap from 20px to 10px */
      overflow: hidden; /* ensure content fits within panel */
    }

    /* LEFT COLUMN => champion card */
    .card-column {
      display: flex;
      align-items: flex-start;
      justify-content: flex-end;  /* Change to flex-end for right alignment */
      flex: 0 0 50%; /* Increase from 40% to 50% */
      overflow: hidden;
      padding-right: 0;  /* Remove any padding */
    }
    .champion-card {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 8px;
    }

    /* RIGHT COLUMN => evolutions, stats, etc. */
    .info-column {
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      flex: 0 0 auto; /* Change from flex: 1 to flex: 0 0 auto */
      overflow: hidden;
      width: 220px; /* Set fixed width */
    }
    .evolutions-label {
      font-size: 18px;  /* Increased from 14px */
      color: #fff;  /* Changed from #aaa to white for better visibility */
      margin-top: 20px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .champion-number {
      color: #888;
      font-size: 16px;
    }
    .champion-rarity-tag {
      font-size: 14px;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: bold;
    }
    .rarity-common { 
      background-color: #404040; /* Dark grey */
      color: #fff;
    }
    .rarity-uncommon { background-color: #27AE60; }
    .rarity-rare { 
      background: linear-gradient(135deg, #C0C0C0, #E8E8E8, #C0C0C0); /* Silver gradient */
      color: #000;
    }
    .rarity-epic { background-color: #8E44AD; }
    .rarity-legendary { background-color: #F39C12; }
    .rarity-diamond { 
      background: linear-gradient(135deg, #B9F2FF, #E6FBFF, #B9F2FF); /* Diamond gradient */
      color: #000;
    }
    .rarity-mythic { 
      background: linear-gradient(135deg, #FFD700, #FFC800, #FFD700); /* Gold gradient */
      color: #000;
    }
    .evolutions-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
      width: auto;  /* Change from fixed width to auto */
    }
    .evolution-item {
      background-color: #333;
      border-radius: 4px;
      padding: 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    .evolution-item.current {
      background-color: #ffff00;
      box-shadow: 0 0 15px rgba(255,255,0,0.3);
      transform: scale(1.05);
    }
    .evolution-item.current::after {
      content: '';
      position: absolute;
      inset: 0;
      border: 2px solid rgba(255,255,0,0.5);
      border-radius: 4px;
      pointer-events: none;
    }
    .evolution-item img {
      width: 53px;
      height: 53px;
      object-fit: contain;
    }
    .evolution-name {
      display: none; /* Hide the name label */
    }
    .stats-line {
      font-size: 14px;
      color: #fff;
      margin-bottom: 10px;
    }

    /* BUY BUTTON pinned at bottom right inside the panel */
    .buy-button {
      bottom: 0px;
      left: 0px;
      font-size: 14px;
      font-weight: bold;
      padding: 6px 12px;  /* Reduce padding */
      border-radius: 6px;
      border: none;
      cursor: pointer;
      white-space: nowrap;  /* Keep text on one line */
      width: fit-content;  /* Make button width fit content */
      min-width: min-content;  /* Ensure minimum width matches content */
    }
    .buy-button.green {
      background-color: #83ff71;
      color: #000;
    }
    .buy-button.green:hover {
      background-color: #70cc60;
    }
    .buy-button.purple {
      background-color: #a781ff;
      color: #000;
    }
    .buy-button.purple:hover {
      background-color: #9570e6;
    }

    /* DRAGGABLE COINS */
    .selector {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: grab;
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(0,0,0,0.5); /* semi-transparent black for better glow effect */
    }
    .selector::after {
      content: "";
      display: block;
      width: 30px;
      height: 30px;
      border: 3px solid currentColor;
      border-radius: 50%;
      box-shadow: 0 0 20px currentColor, inset 0 0 10px currentColor; /* stronger inner and outer glow */
    }
    .selector:active { cursor: grabbing; }

    .orange { 
      color: #ffff00; 
      top: 150px; 
      left: 150px; 
      box-shadow: 0 0 30px #ffff00, 0 0 50px #ffff00; /* double glow effect */
    }
    .blue { 
      color: #00ffff; 
      top: 250px; 
      left: 250px; 
      box-shadow: 0 0 30px #00ffff, 0 0 50px #00ffff; /* double glow effect */
    }

    /* STATS VISUALIZATION */
    .stats-circles {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      justify-content: flex-end;  /* Change to flex-end for right alignment */
      margin-bottom: 1px;
      width: 100%;
    }
    .stat-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      position: relative;
    }
    .stat-circle {
      width: 50px;
      height: 50px;
      position: relative;
    }
    .stat-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: bold;
      font-size: 16px;
      color: white;
      text-shadow: 
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
      z-index: 2;
    }
    .stat-label {
      font-size: 12px;
      color: #aaa;
      font-weight: bold;
    }
    .stat-atk circle.stat-fill { stroke: #ff4444; } /* Brighter red */
    .stat-hp circle.stat-fill { stroke: #44ff44; }  /* Brighter green */
    .stat-mana circle.stat-fill { stroke: #4444ff; } /* Brighter blue */

    /* Info badges */
    .info-badge {
      display: inline-block;
      background: #333;
      padding: 1px 12px;
      border-radius: 6px;
      margin-right: 3px;
      margin-bottom: 0px;
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    /* Add specific styling for orange panel */
    #orangePanel .panel-content {
      gap: 0;  /* Remove gap between columns in orange panel */
    }
    #orangePanel .info-column {
      align-items: flex-start;  /* Left align content in orange panel */
      padding-left: 10px;  /* Add left padding */
    }
    #orangePanel .evolutions-row {
      justify-content: flex-start;  /* Left align evolutions in orange panel */
      width: auto;  /* Change from 100% to auto */
    }
    #orangePanel .extraStats {
      text-align: left;  /* Left align the element/ability text */
      width: 100%;
    }
  </style>
</head>
<body>

  <!-- TOP BAR -->
  <header>
    <div class="logo">CoOMidex</div>
  </header>

  <!-- GENERATION SELECTOR -->
  <div class="gen-selector">
    <div class="gen-option selected">Core Set</div>
    <div class="gen-option">Elemental Warfare</div>
    <div class="gen-option">Gen 3</div>
    <div class="gen-option">Gen 2</div>
    <div class="gen-option">Gen 1</div>
  </div>

  <!-- SCROLLABLE GRID -->
  <div class="main-content">
    <div class="grid-container" id="gridContainer">
      <!-- We'll insert 151 champions here via JS -->
    </div>
  </div>

  <!-- BOTTOM DASH (two adjacent panels) -->
  <footer>
    <!-- ORANGE PANEL -->
    <div class="champion-panel" id="orangePanel">
      <div class="panel-top-bar orange">
        <div class="champion-title" id="orangeTitle">Champion ?</div>
        <div class="champion-rarity" id="orangeRarity">Rare</div>
      </div>
      <div class="panel-content">
        <!-- LEFT COLUMN => champion card -->
        <div class="card-column">
          <img class="champion-card" id="orangeCardImg" src="" alt="" style="display:none;">
        </div>
        <!-- RIGHT COLUMN => evolutions, stats, buy button -->
        <div class="info-column">
          <div class="evolutions-label">Champions</div>
          <div class="evolutions-row" id="orangeEvolutions"></div>
          <div class="stats-line" id="orangeStats">--</div>
          <button class="buy-button green" id="orangeBuyBtn" style="display:none;">Buy now</button>
        </div>
      </div>
    </div>

    <!-- BLUE PANEL -->
    <div class="champion-panel" id="bluePanel">
      <div class="panel-top-bar blue">
        <div class="champion-title" id="blueTitle">Champion ?</div>
        <div class="champion-rarity" id="blueRarity">Rare</div>
      </div>
      <div class="panel-content">
        <!-- LEFT COLUMN => champion card -->
        <div class="card-column">
          <img class="champion-card" id="blueCardImg" src="" alt="" style="display:none;">
        </div>
        <!-- RIGHT COLUMN => evolutions, stats, buy button -->
        <div class="info-column">
          <div class="evolutions-label">Champions</div>
          <div class="evolutions-row" id="blueEvolutions"></div>
          <div class="stats-line" id="blueStats"></div>
          <button class="buy-button purple" id="blueBuyBtn" style="display:none;">Buy now</button>
        </div>
      </div>
    </div>
  </footer>

  <!-- DRAGGABLE COINS -->
  <div id="selectorOrange" class="selector orange"></div>
  <div id="selectorBlue" class="selector blue"></div>

  <script>
    /*******************************************************
     * 1) CREATE THE GRID OF CHAMPIONS
     *******************************************************/
    const gridContainer = document.getElementById('gridContainer');
    let activeCoin = document.getElementById('selectorOrange');  // Start with orange

    // Function to download and unzip images
    async function downloadAndCacheImages() {
      try {
        // Check if images are already cached
        const cachedImages = localStorage.getItem('championImages');
        if (cachedImages) {
          console.log('Images already cached in local storage');
          return;
        }

        console.log('Downloading and caching images...');
        
        // Download the zip file
        const response = await fetch('champion_images.zip');
        const zipBlob = await response.blob();
        
        // Use JSZip to unzip the file
        const zip = new JSZip();
        const unzipped = await zip.loadAsync(zipBlob);
        
        // Create an object to store all images
        const imageCache = {};
        
        // Process each file in the zip
        for (const [filename, file] of Object.entries(unzipped.files)) {
          if (file.dir) continue; // Skip directories
          
          // Convert the file to base64
          const base64 = await file.async('base64');
          imageCache[filename] = base64;
        }
        
        // Store in local storage
        localStorage.setItem('championImages', JSON.stringify(imageCache));
        console.log('Images successfully cached in local storage');
      } catch (error) {
        console.error('Error downloading/caching images:', error);
      }
    }

    // Function to get image from cache or load normally
    function getImageFromCache(num, format, type = 'champion') {
      const cachedImages = localStorage.getItem('championImages');
      if (cachedImages) {
        const imageCache = JSON.parse(cachedImages);
        let filename;
        if (type === 'champion') {
          filename = `${num}.${format}`;
        } else if (type === 'element') {
          filename = `elements/${num.toLowerCase()}.${format}`;
        } else if (type === 'ability') {
          filename = `abilities/${num}.${format}`;
        }
        if (imageCache[filename]) {
          return `data:image/${format};base64,${imageCache[filename]}`;
        }
      }
      // Fallback paths
      if (type === 'champion') {
        return `small pics/${num}.${format}`;
      } else if (type === 'element') {
        return `elements/${num.toLowerCase()}.${format}`;
      } else if (type === 'ability') {
        return `abilities/${num}.${format}`;
      }
    }

    // Modified tryLoadImage function to use cache
    function tryLoadImage(num, type = 'champion') {
      return new Promise((resolve, reject) => {
        // Try png first (since that's what most images are)
        const pngImg = new Image();
        pngImg.onload = () => {
          console.log(`Loaded PNG for ${type} ${num}`);
          resolve('png');
        };
        pngImg.onerror = () => {
          // If png fails, try webp
          const webpImg = new Image();
          webpImg.onload = () => {
            console.log(`Loaded WEBP for ${type} ${num}`);
            resolve('webp');
          };
          webpImg.onerror = () => {
            // If webp fails, try jpg as last resort
            const jpgImg = new Image();
            jpgImg.onload = () => {
              console.log(`Loaded JPG for ${type} ${num}`);
              resolve('jpg');
            };
            jpgImg.onerror = () => {
              console.log(`No image found for ${type} ${num}`);
              reject('no image found');
            };
            jpgImg.src = getImageFromCache(num, 'jpg', type);
          };
          webpImg.src = getImageFromCache(num, 'webp', type);
        };
        pngImg.src = getImageFromCache(num, 'png', type);
      });
    }

    // Load champions data first
    fetch('./champions.json')
      .then(response => response.json())
      .then(data => {
        championsData = data;
        console.log('Data loaded, length:', data.length);
        
        // Start downloading and caching images
        downloadAndCacheImages();
        
        // Filter for Gen 7 (Core Set) champions
        const coreSetChampions = championsData.filter(c => c.generation === 7);
        console.log('Core Set champions:', coreSetChampions.length);

        // Create grid items for Core Set champions
        coreSetChampions.forEach(champion => {
      const div = document.createElement('div');
      div.classList.add('grid-item');
          div.dataset.championNumber = champion.championNumber;
          div.style.display = 'none';  // Hide by default until image loads

      const img = document.createElement('img');
          img.alt = champion.name;
          
          // Try loading both formats
          tryLoadImage(champion.championNumber)
            .then(format => {
              img.src = getImageFromCache(champion.championNumber, format);
              div.style.display = 'flex';  // Only show if image loads successfully
              div.dataset.cardImg = `card pics/${champion.championNumber}.png`;
              console.log(`Champion ${champion.championNumber} (${champion.name}) loaded successfully`);
            })
            .catch(() => {
              div.style.display = 'none';  // Ensure it stays hidden if no image found
              console.log(`Champion ${champion.championNumber} (${champion.name}) has no available image`);
            });

      div.appendChild(img);
      gridContainer.appendChild(div);

      // Clicking => place the active coin on that square (snap)
      div.addEventListener('click', () => {
        placeCoinOnSquare(activeCoin, div);
        // Toggle active coin for next click
        activeCoin = (activeCoin === document.getElementById('selectorOrange')) 
          ? document.getElementById('selectorBlue')
          : document.getElementById('selectorOrange');
      });
        });

        // Force refresh any displayed champions
        if (selectedItemOrange) {
          const champNum = selectedItemOrange.dataset.championNumber;
          const cardImg = selectedItemOrange.dataset.cardImg;
          updateChampionPanel('orange', champNum, cardImg);
        }
        if (selectedItemBlue) {
          const champNum = selectedItemBlue.dataset.championNumber;
          const cardImg = selectedItemBlue.dataset.cardImg;
          updateChampionPanel('blue', champNum, cardImg);
        }
      })
      .catch(error => {
        console.error('Error loading champions data:', error);
      });

    /*******************************************************
     * 2) DRAGGABLE COINS (no snap-on-drop unless click)
     *******************************************************/
    let draggingCoin = null;  // coin currently being dragged
    let offsetX = 0, offsetY = 0;
    let currentHighlightedItem = null;
    let selectedItemOrange = null;
    let selectedItemBlue = null;

    const selectorOrange = document.getElementById('selectorOrange');
    const selectorBlue   = document.getElementById('selectorBlue');

    // MOUSE DOWN => start dragging if coin is clicked
    document.addEventListener('mousedown', e => {
      if (e.target === selectorOrange || e.target === selectorBlue) {
        draggingCoin = e.target;
        activeCoin = draggingCoin; // now this coin is "active"
        const rect = draggingCoin.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
      }
    });

    // MOUSE MOVE => if dragging, move coin + highlight champion
    document.addEventListener('mousemove', e => {
      if (draggingCoin) {
        draggingCoin.style.left = (e.clientX - offsetX) + 'px';
        draggingCoin.style.top  = (e.clientY - offsetY) + 'px';
        updateHighlight(draggingCoin);
      }
    });

    // MOUSE UP => drop coin => no snap
    document.addEventListener('mouseup', e => {
      if (draggingCoin) {
        // remove dashed highlight
        if (currentHighlightedItem) {
          currentHighlightedItem.classList.remove('highlight-orange', 'highlight-blue');
        }
        // check final drop => champion is selected, coin stays
        const rect = draggingCoin.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        draggingCoin.style.pointerEvents = 'none';
        let below = document.elementFromPoint(centerX, centerY);
        draggingCoin.style.pointerEvents = 'auto';

        if (below && below.closest('.grid-item')) {
          const gridItem = below.closest('.grid-item');
          selectChampion(draggingCoin, gridItem);
          // No "placeCoinOnSquare" => coin stays where dropped
        }
        draggingCoin = null;
        currentHighlightedItem = null;
      }
    });

    // highlight champion under coin center
    function updateHighlight(coin) {
      const rect = coin.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      coin.style.pointerEvents = 'none';
      let below = document.elementFromPoint(centerX, centerY);
      coin.style.pointerEvents = 'auto';

      // remove old highlight
      if (currentHighlightedItem) {
        currentHighlightedItem.classList.remove('highlight-orange', 'highlight-blue');
        currentHighlightedItem = null;
      }
      if (below && below.closest('.grid-item')) {
        currentHighlightedItem = below.closest('.grid-item');
        const highlightClass = (coin === selectorOrange) ? 'highlight-orange' : 'highlight-blue';
        currentHighlightedItem.classList.add(highlightClass);
      }
    }

    // place coin in center => only on click
    function placeCoinOnSquare(coin, gridItem) {
      const gridRect = gridItem.getBoundingClientRect();
      const coinRect = coin.getBoundingClientRect();
      const centerX = gridRect.left + (gridRect.width / 2) - (coinRect.width / 2);
      const centerY = gridRect.top + (gridRect.height / 2) - (coinRect.height / 2);
      coin.style.left = centerX + 'px';
      coin.style.top  = centerY + 'px';

      // Also select champion
      selectChampion(coin, gridItem);
    }

    // mark champion as selected => bottom panel updates
    function selectChampion(coin, gridItem) {
      const champNum = gridItem.dataset.championNumber;
      const cardImg  = gridItem.dataset.cardImg;
      if (coin === selectorOrange) {
        if (selectedItemOrange && selectedItemOrange !== gridItem) {
          selectedItemOrange.classList.remove('selected-orange');
        }
        selectedItemOrange = gridItem;
        gridItem.classList.add('selected-orange');
        updateChampionPanel('orange', champNum, cardImg);
      } else {
        if (selectedItemBlue && selectedItemBlue !== gridItem) {
          selectedItemBlue.classList.remove('selected-blue');
        }
        selectedItemBlue = gridItem;
        gridItem.classList.add('selected-blue');
        updateChampionPanel('blue', champNum, cardImg);
      }
    }

    /*******************************************************
     * 3) UPDATE BOTTOM PANELS
     *******************************************************/
    let championsData = [];  // Will store the loaded champion data

    function updateChampionPanel(coin, champNum, cardImg) {
      console.log('Updating panel for champion:', champNum);
      console.log('Champions data loaded:', championsData.length > 0);

      // Panel elements
      const titleEl  = document.getElementById(coin + 'Title');
      const rarityEl = document.getElementById(coin + 'Rarity');
      const imgEl    = document.getElementById(coin + 'CardImg');
      const evoEl    = document.getElementById(coin + 'Evolutions');
      const statsEl  = document.getElementById(coin + 'Stats');
      const buyBtnEl = document.getElementById(coin + 'BuyBtn');

      // Get champion data by finding the champion with matching number
      const champion = championsData.find(c => c.championNumber === parseInt(champNum));
      console.log('Found champion data:', champion ? `${champion.name} (#${champion.championNumber})` : 'Not found');

      if (!champion) {
        console.log('No data found for champion:', champNum);
        // Basic display if no data
        titleEl.textContent = 'Champion ' + champNum;
        
        // Create three distinct badges for unknown champion
        const rarity = document.createElement('span');
        rarity.className = 'info-badge';
        rarity.textContent = 'Unknown';

        const edition = document.createElement('span');
        edition.className = 'info-badge';
        edition.textContent = 'Edition: --';

        const gen = document.createElement('span');
        gen.className = 'info-badge';
        gen.textContent = 'Gen --';

        rarityEl.innerHTML = '';
        rarityEl.appendChild(rarity);
        rarityEl.appendChild(edition);
        rarityEl.appendChild(gen);

        imgEl.src = cardImg;
        imgEl.style.display = 'block';
        
        evoEl.innerHTML = '';
        const baseNum = Math.floor((parseInt(champNum) - 1) / 3) * 3 + 1;
        [baseNum, baseNum + 1, baseNum + 2].forEach(num => {
          const div = createEvolutionItem(num + 1, `Champion ${num}`, num === parseInt(champNum));
          evoEl.appendChild(div);
        });
        
        statsEl.textContent = 'ATK: -- | HP: -- | MANA: -- | Element: -- | Ability: --';
        return;
      }

      console.log('Displaying champion:', champion.name);

      // Update with champion data
      titleEl.textContent = champion.name + (champion.title ? ` - ${champion.title}` : '');
      
      // Show rarity info in separate badges
      const rarity = document.createElement('span');
      rarity.className = 'info-badge';
      rarity.textContent = champion.rarity;

      const edition = document.createElement('span');
      edition.className = 'info-badge';
      edition.textContent = `${champion.edition} Edition`;

      const gen = document.createElement('span');
      gen.className = 'info-badge';
      gen.textContent = `Gen ${champion.generation}`;

      rarityEl.innerHTML = '';
      rarityEl.appendChild(rarity);
      rarityEl.appendChild(edition);
      rarityEl.appendChild(gen);

      if (champion.skin !== 'Classic') {
        const skin = document.createElement('span');
        skin.className = 'info-badge';
        skin.textContent = champion.skin;
        rarityEl.appendChild(skin);
      }

      if (champion.crafted) {
        const crafted = document.createElement('span');
        crafted.className = 'info-badge';
        crafted.textContent = `Crafted: ${champion.crafted}`;
        rarityEl.appendChild(crafted);
      }

      imgEl.src = cardImg;
      imgEl.style.display = 'block';

      // Update evolutions label with champion name, number and rarity
      const evolutionsLabel = coin === 'orange' ? 
        document.querySelector('#orangePanel .evolutions-label') : 
        document.querySelector('#bluePanel .evolutions-label');
      evolutionsLabel.innerHTML = '';
      evolutionsLabel.style.display = 'flex';
      evolutionsLabel.style.alignItems = 'center';
      evolutionsLabel.style.width = '100%';
      evolutionsLabel.style.position = 'relative';

      // Add champion number (fixed to left)
      const numberSpan = document.createElement('span');
      numberSpan.className = 'champion-number';
      numberSpan.textContent = `#${champNum.padStart(3, '0')}`;
      numberSpan.style.marginRight = '15px';
      numberSpan.style.flexShrink = '0'; // Prevent number from shrinking

      // Create a container for the champion name (flexible middle)
      const nameContainer = document.createElement('div');
      nameContainer.style.flex = '1';
      nameContainer.style.display = 'flex';
      nameContainer.style.justifyContent = 'center';
      nameContainer.style.alignItems = 'center';
      nameContainer.style.minWidth = '0'; // Allow container to shrink below content size
      nameContainer.style.overflow = 'hidden'; // Prevent overflow

      // Add champion name with potential scaling
      const nameSpan = document.createElement('span');
      nameSpan.textContent = champion.name;
      nameSpan.style.whiteSpace = 'nowrap'; // Keep on one line
      nameSpan.style.fontSize = '18px'; // Start with default size
      nameContainer.appendChild(nameSpan);

      // Add rarity tag (fixed to right)
      const raritySpan = document.createElement('span');
      raritySpan.className = `champion-rarity-tag rarity-${champion.rarity.toLowerCase()}`;
      raritySpan.textContent = champion.rarity;
      raritySpan.style.marginLeft = '15px';
      raritySpan.style.flexShrink = '0'; // Prevent rarity from shrinking

      // Assemble the layout
      evolutionsLabel.appendChild(numberSpan);
      evolutionsLabel.appendChild(nameContainer);
      evolutionsLabel.appendChild(raritySpan);

      // Check if name needs scaling
      const maxWidth = nameContainer.offsetWidth;
      const nameWidth = nameSpan.offsetWidth;
      if (nameWidth > maxWidth) {
        const scale = maxWidth / nameWidth;
        const newSize = Math.max(12, Math.floor(18 * scale)); // Don't go smaller than 12px
        nameSpan.style.fontSize = `${newSize}px`;
      }

      // Split evolutions string and create evolution boxes
      evoEl.innerHTML = '';
      let evolutions = champion.evolutions.split(', ');
      
      // Create container for evolutions with centered alignment
      const evoContainer = document.createElement('div');
      evoContainer.style.display = 'flex';
      evoContainer.style.gap = '8px';
      evoContainer.style.justifyContent = 'center'; // Always center the evolution items
      evoContainer.style.width = '100%'; // Ensure container takes full width
      
      // Create evolution boxes in the correct order based on the evolution array
      evolutions.forEach((evoName) => {
        // Find the champion data for this evolution name
        const evoChampion = championsData.find(c => c.name === evoName);
        if (evoChampion) {
          const div = createEvolutionItem(
            evoChampion.championNumber, // Use the actual champion number from data
            evoName,
            champion.name === evoName
          );
          evoContainer.appendChild(div);
        }
      });

      evoEl.appendChild(evoContainer);

      // Display all champion stats
      const statsContainer = document.createElement('div');
      statsContainer.className = 'stats-circles';
      
      // Create stat circles
      const stats = [
        { label: 'ATK', value: champion.attack || 0, maxValue: 10, class: 'stat-atk' },
        { label: 'HP', value: champion.health || 0, maxValue: 10, class: 'stat-hp' },
        { label: 'MANA', value: champion.manaCost || 0, maxValue: 10, class: 'stat-mana' }
      ];
      
      stats.forEach(stat => {
        const group = document.createElement('div');
        group.className = 'stat-group';
        
        const circle = document.createElement('div');
        circle.className = `stat-circle ${stat.class}`;
        
        // Create SVG for pie chart
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '50');
        svg.setAttribute('height', '50');
        svg.setAttribute('viewBox', '0 0 50 50');
        
        // Background circle
        const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        bgCircle.setAttribute('cx', '25');
        bgCircle.setAttribute('cy', '25');
        bgCircle.setAttribute('r', '22');
        bgCircle.setAttribute('fill', '#333');
        bgCircle.setAttribute('stroke-width', '3');
        
        // Foreground circle (pie slice)
        const fillCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        fillCircle.setAttribute('cx', '25');
        fillCircle.setAttribute('cy', '25');
        fillCircle.setAttribute('r', '22');
        fillCircle.setAttribute('fill', 'none');
        fillCircle.setAttribute('stroke-width', '3');
        fillCircle.classList.add('stat-fill');
        
        // Calculate percentage and stroke-dasharray
        const percentage = (stat.value / stat.maxValue);
        const circumference = 2 * Math.PI * 22;
        fillCircle.setAttribute('stroke-dasharray', `${circumference * percentage} ${circumference}`);
        fillCircle.setAttribute('transform', 'rotate(-90 25 25)');
        
        svg.appendChild(bgCircle);
        svg.appendChild(fillCircle);
        circle.appendChild(svg);
        
        // Add the value text
        const value = document.createElement('div');
        value.className = 'stat-value';
        value.textContent = stat.value;
        circle.appendChild(value);
        
        group.appendChild(circle);
        statsContainer.appendChild(group);
      });
      
      // Clear and update stats display
      statsEl.innerHTML = '';
      statsEl.appendChild(statsContainer);
      
      // Add element and ability text below circles
      const extraStats = document.createElement('div');
      extraStats.className = 'extraStats';  // Add a class for easier reference
      extraStats.style.marginTop = '10px';
      extraStats.style.marginBottom = '2px';
      extraStats.style.color = '#fff';
      extraStats.style.display = 'flex';
      extraStats.style.alignItems = 'center';
      extraStats.style.justifyContent = 'center';
      extraStats.style.width = '100%';
      extraStats.style.position = 'relative';

      if (champion) {
        let hasIcons = 0;  // Counter for number of icons

        // Element section
        if (champion.element && champion.element !== "----") {
          const elementSection = document.createElement('div');
          elementSection.style.display = 'flex';
          elementSection.style.alignItems = 'center';
          elementSection.style.justifyContent = 'center';
          elementSection.style.flex = '1';
          
          const elementImg = document.createElement('img');
          // Use the caching system for element images
          tryLoadImage(champion.element, 'element')
            .then(format => {
              elementImg.src = getImageFromCache(champion.element, format, 'element');
            })
            .catch(() => {
              console.log(`Element image ${champion.element} not found`);
              elementImg.src = `elements/${champion.element.toLowerCase()}.png`; // Fallback
            });
          elementImg.alt = champion.element;
          elementImg.style.height = '40px';
          elementImg.style.width = '40px';
          elementImg.style.objectFit = 'contain';
          
          elementSection.appendChild(elementImg);
          extraStats.appendChild(elementSection);
          hasIcons++;
        }

        // Ability section
        if (champion.ability && champion.ability !== "----") {
          const abilitySection = document.createElement('div');
          abilitySection.style.display = 'flex';
          abilitySection.style.alignItems = 'center';
          abilitySection.style.justifyContent = 'center';
          abilitySection.style.flex = '1';
          abilitySection.style.gap = '4px';

          // Split abilities if there's a |
          const abilities = champion.ability.split('|').map(a => a.trim());
          
          abilities.forEach(ability => {
            const abilityImg = document.createElement('img');
            const abilityName = ability
              .replace(/\s*\(\d+\)\s*/g, '')
              .replace(/\s+/g, '');
            // Use the caching system for ability images
            tryLoadImage(abilityName, 'ability')
              .then(format => {
                abilityImg.src = getImageFromCache(abilityName, format, 'ability');
              })
              .catch(() => {
                console.log(`Ability image ${abilityName} not found`);
                abilityImg.src = `abilities/${abilityName}.png`; // Fallback
              });
            abilityImg.alt = ability;
            abilityImg.style.height = '40px';
            abilityImg.style.width = '40px';
            abilityImg.style.objectFit = 'contain';
            
            abilitySection.appendChild(abilityImg);
          });
          
          extraStats.appendChild(abilitySection);
          hasIcons++;
        }

        // Adjust spacing based on number of icons
        if (hasIcons === 2) {
          extraStats.style.justifyContent = 'space-evenly'; // Changed from space-around to space-evenly
        } else if (hasIcons === 1) {
          extraStats.style.justifyContent = 'center';
        }
      } else {
        extraStats.innerHTML = '--';
      }
      statsEl.appendChild(extraStats);

      // Show the buy button - wait for next frame to ensure extraStats width is calculated
      requestAnimationFrame(() => {
        buyBtnEl.className = '';
        buyBtnEl.style.display = 'flex';
        buyBtnEl.style.alignItems = 'center';
        buyBtnEl.style.justifyContent = 'center';
        buyBtnEl.style.gap = '0';
        buyBtnEl.style.cursor = 'pointer';
        buyBtnEl.style.transition = 'all 0.2s ease';
        buyBtnEl.style.border = 'none';
        buyBtnEl.style.outline = 'none';
        buyBtnEl.style.boxShadow = 'none';
        buyBtnEl.style.padding = '0';
        buyBtnEl.style.margin = '0';
        buyBtnEl.style.backgroundColor = 'transparent';
        buyBtnEl.style.appearance = 'none';
        buyBtnEl.style.WebkitAppearance = 'none';
        buyBtnEl.style.MozAppearance = 'none';
        buyBtnEl.style.width = extraStats.offsetWidth + 'px';

        // Create container for pill shape
        const pillContainer = document.createElement('div');
        pillContainer.style.display = 'flex';
        pillContainer.style.backgroundColor = '#000';
        pillContainer.style.borderRadius = '100px';
        pillContainer.style.overflow = 'hidden';
        pillContainer.style.width = 'fit-content';
        pillContainer.style.margin = '0 auto'; // Center horizontally

        // Create HandCash logo section (left side)
        const logoSection = document.createElement('div');
        logoSection.style.padding = '8px 6px 8px 12px';  // Reduced right padding
        logoSection.style.backgroundColor = 'transparent';
        logoSection.style.display = 'flex';
        logoSection.style.alignItems = 'center';

        // Create HandCash logo
        const handcashLogo = document.createElement('img');
        handcashLogo.src = 'handcash.webp';
        handcashLogo.alt = 'HandCash';
        handcashLogo.style.height = '20px';
        handcashLogo.style.width = '20px';
        handcashLogo.style.objectFit = 'contain';

        // Create price section (right side)
        const priceSection = document.createElement('div');
        priceSection.style.display = 'flex';
        priceSection.style.alignItems = 'center';
        priceSection.style.padding = '8px 12px 8px 6px';  // Reduced left padding
        priceSection.style.backgroundColor = 'transparent';
        priceSection.style.border = 'none';

        // Create price text
        const priceText = document.createElement('span');
        priceText.style.color = '#666'; // Grayed out text
        priceText.style.fontSize = '14px';
        priceText.style.fontWeight = 'bold';
        priceText.textContent = 'Coming Soon';  // Replace price with Coming Soon

        // Hover effects - disabled
        buyBtnEl.onmouseover = null;
        buyBtnEl.onmouseout = null;
        buyBtnEl.style.cursor = 'not-allowed';
        buyBtnEl.onclick = null; // Remove click handler

        // Assemble the widget
        logoSection.appendChild(handcashLogo);
        priceSection.appendChild(priceText);

        pillContainer.appendChild(logoSection);
        pillContainer.appendChild(priceSection);

        buyBtnEl.innerHTML = '';
        buyBtnEl.appendChild(pillContainer);
      });
    }

    // Update the evolution items image loading as well
    function createEvolutionItem(num, evo, isCurrentEvolution) {
      const div = document.createElement('div');
      div.className = 'evolution-item';
      
      // Add small image using the found champion number
      const img = document.createElement('img');
      
      // Try loading both formats
      tryLoadImage(num)
        .then(format => {
          img.src = getImageFromCache(num, format);
        })
        .catch(() => {
          console.log(`Evolution image ${num} not found in either format`);
          img.src = 'placeholder.png'; // You might want to add a placeholder image
        });
      
      img.alt = evo;
      div.appendChild(img);
      
      // Add name
      const name = document.createElement('div');
      name.className = 'evolution-name';
      name.textContent = evo;
      div.appendChild(name);
      
      // Highlight current evolution
      if (isCurrentEvolution) {
        div.classList.add('current');
      }
      
      return div;
    }
  </script>
</body>
</html>
